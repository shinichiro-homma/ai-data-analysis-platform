# タスク詳細: 3.5 session_connect ツール実装

## 概要

ブラウザでJupyterLabを開いて作業中のノートブックに、MCPクライアント（Claude等）から接続できるようにする「session_connect」ツールを実装する。

これにより**ユーザー先行パターン**（ユーザーがブラウザでノートブックを開き、後からAIが同じカーネルに接続して支援する）が可能になる。

### ユースケース

1. ユーザーがブラウザでJupyterLabを開き、ノートブック `analysis.ipynb` で作業開始
2. ユーザーが変数 `df` にデータを読み込む
3. ユーザーがAI（MCP経由）に「このデータを可視化して」と依頼
4. AIが `session_connect` で既存セッションに接続
5. AIがユーザーと同じ `df` 変数にアクセスして可視化コードを実行

## 関連ドキュメント

- 要件定義: `docs/requirements/jupyter-mcp.md` の「F1.4: 既存セッションへの接続」セクション
- API仕様: `docs/design/api-contracts.md` の「カーネル管理」セクション
- MCP実装パターン: `.claude/skills/mcp-typescript-server/SKILL.md`

## 実装計画

### 前提: Jupyter Server の動作

Jupyter Serverでは、ブラウザでノートブックを開くと**セッション**が作成される。セッションは以下の情報を持つ:
- ノートブックパス
- 関連するカーネルID

現在の実装では `session_list` は「カーネル一覧」のみを返しており、「どのカーネルがどのノートブックに関連しているか」の情報がない。

Jupyter Server の標準APIには `/api/sessions` エンドポイントがあり、これがノートブックとカーネルの対応関係を提供する。

### 作成するファイル

| ファイル | 内容 |
|----------|------|
| `jupyter-mcp/src/tools/session-connect.ts` | session_connect ツールの実装 |
| `jupyter-mcp/src/tools/index.ts` | ツール定義の追加・ルーティング追加 |
| `jupyter-mcp/src/jupyter-client/client.ts` | Sessions API クライアントメソッド追加 |
| `jupyter-mcp/src/jupyter-client/types.ts` | Session 型定義の追加 |
| `jupyter-mcp/tests/integration/session-connect.test.ts` | 結合テスト |

### 実装手順

#### 1. Session 型定義の追加

`jupyter-mcp/src/jupyter-client/types.ts` に以下を追加:

```typescript
// Jupyter Server の /api/sessions が返すセッション情報
export interface JupyterSession {
  id: string;
  path: string;           // ノートブックパス
  name: string;           // ノートブック名
  type: 'notebook';
  kernel: {
    id: string;
    name: string;
    last_activity: string;
    execution_state: KernelStatus;
    connections: number;
  };
}
```

#### 2. JupyterClient に Sessions API メソッド追加

`jupyter-mcp/src/jupyter-client/client.ts` に以下を追加:

```typescript
// セッション一覧を取得（ノートブックとカーネルの対応関係）
async listSessions(): Promise<JupyterSession[]> {
  const response = await this.request<JupyterSession[]>('GET', '/api/sessions');
  return response;
}

// 指定パスのノートブックに関連するセッションを取得
async getSessionByPath(notebookPath: string): Promise<JupyterSession | null> {
  const sessions = await this.listSessions();
  return sessions.find(s => s.path === notebookPath || s.path === notebookPath.replace(/^\//, '')) ?? null;
}

// 指定カーネルIDに関連するセッションを取得
async getSessionByKernelId(kernelId: string): Promise<JupyterSession | null> {
  const sessions = await this.listSessions();
  return sessions.find(s => s.kernel.id === kernelId) ?? null;
}
```

**注意**: Jupyter Server の `/api/sessions` はカスタムAPI (`/api/kernels`) と異なり、標準APIなのでレスポンス形式が異なる（`data` ラッパーがない）。

#### 3. session_connect ツール実装

`jupyter-mcp/src/tools/session-connect.ts` を新規作成:

```typescript
/**
 * session_connect ツール実装
 *
 * 既存のセッション（ブラウザで開いているノートブック）に接続する
 */

import { jupyterClient } from "../jupyter-client/client.js";
import {
  createSuccessResponse,
  createErrorResponse,
  extractErrorCode,
  extractErrorMessage,
  type McpResponse,
} from "../utils/response-formatter.js";
import { validateStringParameter } from "../utils/validation.js";

interface SessionConnectArgs {
  notebook_path?: string;
  kernel_id?: string;
}

export async function executeSessionConnect(
  args: Record<string, unknown>
): Promise<McpResponse> {
  const { notebook_path, kernel_id } = args as SessionConnectArgs;

  // 入力検証: notebook_path または kernel_id のどちらかが必要
  if (!notebook_path && !kernel_id) {
    return createErrorResponse(
      "notebook_path または kernel_id のどちらかを指定してください",
      "VALIDATION_ERROR"
    );
  }

  // notebook_path のバリデーション
  if (notebook_path) {
    const pathValidation = validateStringParameter(notebook_path, "notebook_path", {
      maxLength: 500,
    });
    if (!pathValidation.isValid) {
      return createErrorResponse(
        pathValidation.errorMessage!,
        "VALIDATION_ERROR"
      );
    }
  }

  // kernel_id のバリデーション
  if (kernel_id) {
    const kernelValidation = validateStringParameter(kernel_id, "kernel_id", {
      maxLength: 100,
    });
    if (!kernelValidation.isValid) {
      return createErrorResponse(
        kernelValidation.errorMessage!,
        "VALIDATION_ERROR"
      );
    }
  }

  try {
    let session;

    if (notebook_path) {
      // ノートブックパスでセッションを検索
      session = await jupyterClient.getSessionByPath(notebook_path);
      if (!session) {
        return createErrorResponse(
          `指定されたノートブックに関連するセッションが見つかりません: ${notebook_path}`,
          "SESSION_NOT_FOUND"
        );
      }
    } else {
      // カーネルIDでセッションを検索
      session = await jupyterClient.getSessionByKernelId(kernel_id!);
      if (!session) {
        return createErrorResponse(
          `指定されたカーネルに関連するセッションが見つかりません: ${kernel_id}`,
          "SESSION_NOT_FOUND"
        );
      }
    }

    return createSuccessResponse({
      session_id: session.id,
      kernel_id: session.kernel.id,
      notebook_path: session.path,
      status: session.kernel.execution_state,
      connected: true,
    });
  } catch (error) {
    return createErrorResponse(
      extractErrorMessage(error),
      extractErrorCode(error)
    );
  }
}
```

#### 4. ツール定義・ルーティング追加

`jupyter-mcp/src/tools/index.ts` を更新:

- tools 配列に session_connect の定義を追加
- import に `executeSessionConnect` を追加
- handleToolCall の switch に case を追加

#### 5. 結合テスト作成

`jupyter-mcp/tests/integration/session-connect.test.ts` を新規作成:

```typescript
describe('session_connect の結合テスト', () => {
  test('notebook_path でブラウザのセッションに接続できる', async () => {
    // 1. ノートブックを作成
    // 2. Jupyter API で直接セッションを作成（ブラウザが開いた状態をシミュレート）
    // 3. session_connect(notebook_path) で接続
    // 4. 接続成功、kernel_id が返ることを確認
  });

  test('kernel_id でセッションに接続できる', async () => {
    // 1. ノートブックを作成
    // 2. セッションを作成
    // 3. session_connect(kernel_id) で接続
    // 4. 接続成功、notebook_path が返ることを確認
  });

  test('存在しない notebook_path でエラーが返る', async () => {
    // SESSION_NOT_FOUND エラーを確認
  });

  test('notebook_path も kernel_id も指定しないとエラーが返る', async () => {
    // VALIDATION_ERROR を確認
  });
});
```

### 技術的な考慮事項

#### Jupyter Server 標準API と カスタムAPI の違い

- 現在の `/api/kernels` はカスタムAPI（`{data: ...}` 形式）
- `/api/sessions` は Jupyter Server 標準API（配列が直接返る）
- JupyterClient でリクエスト時にレスポンス形式を適切にハンドリングする必要がある

#### パス正規化

- ブラウザでノートブックを開くと、パスは `analysis.ipynb` のように先頭の `/` がない場合がある
- `session_connect` では `/analysis.ipynb` と `analysis.ipynb` の両方でマッチするよう実装する

#### 「接続」の意味

- 実際にはカーネルへの新しい接続を確立するわけではない
- 既存のセッション情報を取得し、そのカーネルIDを返すことで、以後の `execute_code` 等で同じカーネルを使えるようにする
- つまり、カーネルIDの「発見」と「検証」を行うツール

## 完了条件

- [x] `session_connect` ツールが実装されている
- [x] `notebook_path` を指定して既存セッションに接続できる
- [x] `kernel_id` を指定して既存セッションに接続できる
- [x] 接続成功時に `session_id`, `kernel_id`, `notebook_path`, `status`, `connected` が返る
- [x] 存在しないセッションを指定すると `SESSION_NOT_FOUND` エラーが返る
- [x] 入力バリデーションが機能する
- [x] 結合テストが通る

## テスト計画

### 単体テスト（モック）

- 入力バリデーションのテスト
- エラーハンドリングのテスト

### 結合テスト（実際の Jupyter Server を使用）

1. **正常系: notebook_path での接続**
   - ノートブックを作成
   - Jupyter Sessions API でセッション作成（ブラウザで開いた状態をシミュレート）
   - `session_connect` で接続
   - 返却値を検証

2. **正常系: kernel_id での接続**
   - 上記と同様にセッションを作成
   - カーネルIDを取得
   - `session_connect(kernel_id=...)` で接続

3. **異常系: セッションが見つからない**
   - 存在しないパスで接続を試みる
   - `SESSION_NOT_FOUND` エラーを確認

4. **異常系: 入力なし**
   - 引数なしで呼び出す
   - `VALIDATION_ERROR` を確認

---

## レビューステータス

- [x] 計画レビュー完了
- [x] 実装完了
- [x] テスト完了
